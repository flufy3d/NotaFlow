<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>实时音高图表</title>
  <style>
    body {
      background: #f0f0f0;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
    }
    /* Center container by fixed width and auto margin */
    #container {
      position: relative;
      width: 800px; /* Adjust the width as needed */
      height: 600px; /* Adjust the height as needed */
      margin: 40px auto; /* Center horizontally */
      border: 1px solid #000;
      background: #fff;
    }
    /* Overlapping canvases */
    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    h1, p {
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>实时音高图表</h1>
  <p>请允许麦克风访问</p>
  <div id="container">
    <!-- Dynamic grid canvas -->
    <canvas id="grid" width="800" height="600"></canvas>
    <!-- Dynamic graph canvas -->
    <canvas id="graph" width="800" height="600"></canvas>
  </div>

  <script>
    // Get canvas elements and contexts
    const gridCanvas = document.getElementById('grid');
    const gridCtx = gridCanvas.getContext('2d');
    const graphCanvas = document.getElementById('graph');
    const graphCtx = graphCanvas.getContext('2d');
    const canvasWidth = graphCanvas.width;
    const canvasHeight = graphCanvas.height;

    // Define full MIDI range from A0 to C8
    const fullMinMidi = 21;   // A0
    const fullMaxMidi = 108;  // C8
    // Number of octaves to display in dynamic window
    const displayOctaves = 3;
    const displayRange = displayOctaves * 12; // semitones

    // History array to store pitch (MIDI value) for each x-pixel
    let pitchHistory = [];

    // Note names array for labeling
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

    // Draw dynamic grid according to current window (windowMinMidi to windowMaxMidi)
    function drawDynamicGrid(windowMinMidi, windowMaxMidi) {
      // Clear the grid canvas
      gridCtx.clearRect(0, 0, canvasWidth, canvasHeight);
      // Determine integer boundaries for grid lines
      const startMidi = Math.floor(windowMinMidi);
      const endMidi = Math.ceil(windowMaxMidi);
      for (let midi = startMidi; midi <= endMidi; midi++) {
        // Map current MIDI note to y-coordinate
        let y = canvasHeight - ((midi - windowMinMidi) / (windowMaxMidi - windowMinMidi)) * canvasHeight;
        // Determine next y-coordinate for filling stripe
        let nextMidi = midi + 1;
        let nextY = canvasHeight - ((nextMidi - windowMinMidi) / (windowMaxMidi - windowMinMidi)) * canvasHeight;
        // Fill alternating background colors for semitone stripes
        gridCtx.fillStyle = (midi % 2 === 0) ? '#f9f9f9' : '#ffffff';
        if (nextY < y) {
          gridCtx.fillRect(0, nextY, canvasWidth, y - nextY);
        }
        // Draw horizontal grid line
        gridCtx.beginPath();
        gridCtx.moveTo(0, y);
        gridCtx.lineTo(canvasWidth, y);
        gridCtx.strokeStyle = '#ccc';
        gridCtx.lineWidth = 1;
        gridCtx.stroke();
        // Label natural notes (skip sharps)
        let noteIndex = midi % 12;
        let octave = Math.floor(midi / 12) - 1;
        let noteName = noteNames[noteIndex] + octave;
        if (noteNames[noteIndex].indexOf('#') === -1) {
          gridCtx.fillStyle = 'black';
          gridCtx.font = '12px Arial';
          gridCtx.fillText(noteName, 5, y - 2);
        }
      }
    }

    // Convert frequency to MIDI note (floating point)
    function frequencyToMidi(frequency) {
      return 69 + 12 * Math.log2(frequency / 440);
    }

    // Autocorrelation algorithm for pitch detection
    // Analyze the audio buffer and return the detected pitch in Hz
    function autoCorrelate(buffer, sampleRate) {
      let SIZE = buffer.length;
      let rms = 0;
      // Calculate RMS to check signal strength
      for (let i = 0; i < SIZE; i++) {
        let val = buffer[i];
        rms += val * val;
      }
      rms = Math.sqrt(rms / SIZE);
      if (rms < 0.01) {
        return -1;  // signal too weak
      }
      let r1 = 0, r2 = SIZE - 1;
      // Trim buffer edges
      for (let i = 0; i < SIZE / 2; i++) {
        if (Math.abs(buffer[i]) < 0.2) {
          r1 = i;
          break;
        }
      }
      for (let i = 1; i < SIZE / 2; i++) {
        if (Math.abs(buffer[SIZE - i]) < 0.2) {
          r2 = SIZE - i;
          break;
        }
      }
      buffer = buffer.slice(r1, r2);
      SIZE = buffer.length;
      let c = new Array(SIZE).fill(0);
      // Autocorrelation
      for (let lag = 0; lag < SIZE; lag++) {
        for (let i = 0; i < SIZE - lag; i++) {
          c[lag] += buffer[i] * buffer[i + lag];
        }
      }
      let d = 0;
      // Find first dip
      while (c[d] > c[d + 1]) {
        d++;
      }
      let maxval = -1, maxpos = -1;
      // Find peak after dip
      for (let i = d; i < SIZE; i++) {
        if (c[i] > maxval) {
          maxval = c[i];
          maxpos = i;
        }
      }
      let T0 = maxpos;
      // Parabolic interpolation for better accuracy
      let x1 = c[T0 - 1];
      let x2 = c[T0];
      let x3 = c[T0 + 1];
      let a = (x1 + x3 - 2 * x2) / 2;
      let b = (x3 - x1) / 2;
      if (a) {
        T0 = T0 - b / (2 * a);
      }
      let pitch = sampleRate / T0;
      return pitch;
    }

    // Draw graph using stored pitchHistory with current dynamic window mapping
    function drawGraph(pitchHistory, windowMinMidi, windowMaxMidi) {
      // Clear the graph canvas
      graphCtx.clearRect(0, 0, canvasWidth, canvasHeight);
      graphCtx.beginPath();
      let started = false;
      for (let i = 0; i < pitchHistory.length; i++) {
        let midi = pitchHistory[i];
        // Skip if pitch not detected
        if (midi === null) {
          if (started) {
            graphCtx.stroke();
            graphCtx.beginPath();
            started = false;
          }
          continue;
        }
        // Map MIDI value to y-coordinate based on dynamic window
        let y = canvasHeight - ((midi - windowMinMidi) / (windowMaxMidi - windowMinMidi)) * canvasHeight;
        let x = i; // x coordinate corresponds to history index (each index = 1 pixel)
        if (!started) {
          graphCtx.moveTo(x, y);
          started = true;
        } else {
          graphCtx.lineTo(x, y);
        }
      }
      if (started) {
        graphCtx.strokeStyle = 'red';
        graphCtx.lineWidth = 2;
        graphCtx.stroke();
      }
    }

    // Audio processing variables
    let audioContext, analyser, mediaStreamSource;
    let bufferLength;
    let dataArray;
    let pitchSmoothed = 0;

    // Main loop: process audio, update dynamic window, grid and graph
    function update() {
      analyser.getFloatTimeDomainData(dataArray);
      let pitch = autoCorrelate(dataArray, audioContext.sampleRate);
      let currentMidi = null;
      if (pitch !== -1) {
        // Apply smoothing filter
        pitchSmoothed = pitchSmoothed * 0.8 + pitch * 0.2;
        currentMidi = frequencyToMidi(pitchSmoothed);
      }
      // Compute dynamic window boundaries based on current pitch.
      // If no pitch detected,则保持上次窗口不变；这里简单处理：使用中间值作为当前值
      let centerMidi = currentMidi !== null ? currentMidi : (fullMinMidi + fullMaxMidi) / 2;
      let windowMinMidi = centerMidi - displayRange / 2;
      let windowMaxMidi = centerMidi + displayRange / 2;
      // Clamp the dynamic window within full range
      if (windowMinMidi < fullMinMidi) {
        windowMinMidi = fullMinMidi;
        windowMaxMidi = fullMinMidi + displayRange;
      }
      if (windowMaxMidi > fullMaxMidi) {
        windowMaxMidi = fullMaxMidi;
        windowMinMidi = fullMaxMidi - displayRange;
      }
      // Redraw the grid according to dynamic window
      drawDynamicGrid(windowMinMidi, windowMaxMidi);
      // Update pitch history array (each element对应一个像素)
      // If pitch not detected, push null
      pitchHistory.push(currentMidi);
      if (pitchHistory.length > canvasWidth) {
        pitchHistory.shift();
      }
      // Redraw the graph based on pitch history and current dynamic window
      drawGraph(pitchHistory, windowMinMidi, windowMaxMidi);
      requestAnimationFrame(update);
    }

    // Initialize audio stream and start processing
    async function init() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        mediaStreamSource = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        bufferLength = analyser.fftSize;
        dataArray = new Float32Array(bufferLength);
        mediaStreamSource.connect(analyser);
        update();
      } catch (e) {
        console.error('Error accessing audio stream:', e);
        alert('无法访问麦克风，请检查权限设置');
      }
    }

    window.addEventListener('load', init);
  </script>
</body>
</html>
