<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>MIDI 修复工具</title>
</head>
<body>
  <h1>MIDI 修复工具</h1>
  <p>请选择一个 MIDI 文件上传：</p>
  <input type="file" id="midiFileInput" accept=".mid,.midi">
  <div id="output" style="margin-top:20px;"></div>
  <br>
  <a id="downloadLink" style="display:none;">下载修复后的 MIDI 文件</a>
  
  <!-- Import JZZ MIDI 库，用于解析和导出 MIDI 文件 -->
  <script src="https://cdn.jsdelivr.net/npm/jzz"></script>
  <script src="https://cdn.jsdelivr.net/npm/jzz-midi-smf"></script>
  
  <script>
  // 监听文件上传
  document.getElementById('midiFileInput').addEventListener('change', function(event) {
    var file = event.target.files[0];
    if (!file) return;
    var reader = new FileReader();
    reader.onload = function(e) {
      var arrayBuffer = e.target.result;
      // Convert ArrayBuffer to binary string for JZZ library
      var byteArray = new Uint8Array(arrayBuffer);
      var binaryStr = "";
      for (var i = 0; i < byteArray.length; i++) {
        binaryStr += String.fromCharCode(byteArray[i]);
      }
      // Parse the MIDI file using JZZ.MIDI.SMF
      var smf = new JZZ.MIDI.SMF(binaryStr);
      
      // Define a velocity threshold for glitch notes removal
      var glitchThreshold = 20; // Notes with velocity < threshold will be removed
      // Define grid tick value for aligning note timing (adjust based on your MIDI file resolution)
      var grid = 120;
      // Array to count pitch occurrence (for key detection)
      var pitchCount = new Array(12).fill(0);
      
      // Iterate over each track (index 0 is header, so start from 1)
      for (var t = 1; t < smf.length; t++) {
        var track = smf[t];
        // Calculate absolute times for each event in the track
        var absTimes = [];
        var currentTime = 0;
        for (var j = 0; j < track.length; j++) {
          // track[j][0] is delta time, track[j][1] is the MIDI message array
          currentTime += track[j][0];
          absTimes.push(currentTime);
        }
        
        // New events array after processing
        var newEvents = [];
        var lastTime = 0;
        
        // Object to track active glitch notes (key: note number)
        var activeGlitches = {};
        
        // Iterate over each event in the track
        for (var j = 0; j < track.length; j++) {
          var delta = track[j][0];
          var evt = track[j][1]; // MIDI message, e.g., [status, note, velocity]
          var absTime = absTimes[j];
          // Align the absolute time to the nearest grid value
          var alignedTime = Math.round(absTime / grid) * grid;
          var newDelta = alignedTime - lastTime;
          lastTime = alignedTime;
          
          // Determine the event type by checking the status nibble
          var status = evt[0] & 0xF0;
          if (status === 0x90) { // Note On event
            var note = evt[1];
            var velocity = evt[2];
            if (velocity < glitchThreshold) {
              // If velocity is below threshold, mark this note as glitch and skip the event
              activeGlitches[note] = true;
              continue;
            } else {
              // Count the note for key detection
              pitchCount[note % 12]++;
            }
          } else if (status === 0x80) { // Note Off event
            var note = evt[1];
            // If the corresponding Note On was a glitch, skip this Note Off too
            if (activeGlitches[note]) {
              delete activeGlitches[note];
              continue;
            }
          }
          // For other events (including Meta events), keep them
          newEvents.push([newDelta, evt]);
        }
        // Replace the original track events with the processed events
        track.length = 0;
        for (var j = 0; j < newEvents.length; j++) {
          track.push(newEvents[j]);
        }
      }
      
      // Determine the main key based on the most frequent pitch (simplified algorithm)
      var maxCount = 0;
      var mainKeyIndex = 0;
      for (var i = 0; i < 12; i++) {
        if (pitchCount[i] > maxCount) {
          maxCount = pitchCount[i];
          mainKeyIndex = i;
        }
      }
      var keyNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
      var mainKey = keyNames[mainKeyIndex] + "大调";
      
      // Display the detected key to the user
      document.getElementById('output').innerText = "检测到主调式: " + mainKey;
      
      // Dump the modified SMF back to a binary string
      var fixedBinary = smf.dump();
      
      // Convert the binary string to a Uint8Array for Blob creation
      var fixedBytes = new Uint8Array(fixedBinary.split('').map(function(c) {
        return c.charCodeAt(0);
      }));
      var blob = new Blob([fixedBytes], {type: "audio/midi"});
      
      // Create and show the download link for the fixed MIDI file
      var downloadLink = document.getElementById('downloadLink');
      downloadLink.href = URL.createObjectURL(blob);
      downloadLink.download = "fixed_" + file.name;
      downloadLink.style.display = "block";
      downloadLink.innerText = "点击下载修复后的 MIDI 文件";
    };
    reader.readAsArrayBuffer(file);
  });
  </script>
</body>
</html>
