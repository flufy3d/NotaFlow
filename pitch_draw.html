<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>实时音高图表 (改进版)</title>
  <style>
    body {
      background: #f0f0f0;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
    }
    /* Center container by fixed width and auto margin */
    #container {
      position: relative;
      width: 800px; /* Adjust the width as needed */
      height: 600px; /* Adjust the height as needed */
      margin: 40px auto; /* Center horizontally */
      border: 1px solid #000;
      background: #fff;
      overflow: hidden; /* Prevents minor rendering glitches at edges */
    }
    /* Overlapping canvases */
    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    h1, p {
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>实时音高图表 (改进版)</h1>
  <p>请允许麦克风访问。此版本减少了图表整体抖动。</p>
  <div id="container">
    <!-- Dynamic grid canvas -->
    <canvas id="grid" width="800" height="600"></canvas>
    <!-- Dynamic graph canvas -->
    <canvas id="graph" width="800" height="600"></canvas>
  </div>

  <script>
    // Get canvas elements and contexts
    const gridCanvas = document.getElementById('grid');
    const gridCtx = gridCanvas.getContext('2d');
    const graphCanvas = document.getElementById('graph');
    const graphCtx = graphCanvas.getContext('2d');
    const canvasWidth = graphCanvas.width;
    const canvasHeight = graphCanvas.height;

    // Define full MIDI range from A0 to C8
    const fullMinMidi = 21;   // A0
    const fullMaxMidi = 108;  // C8
    // Number of octaves to display in dynamic window
    const displayOctaves = 3;
    const displayRange = displayOctaves * 12; // semitones

    // History array to store pitch (MIDI value) for each x-pixel
    let pitchHistory = [];

    // Note names array for labeling
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

    // Draw dynamic grid according to current window (windowMinMidi to windowMaxMidi)
    function drawDynamicGrid(windowMinMidi, windowMaxMidi) {
      // Clear the grid canvas
      gridCtx.clearRect(0, 0, canvasWidth, canvasHeight);
      // Determine integer boundaries for grid lines
      const startMidi = Math.floor(windowMinMidi);
      const endMidi = Math.ceil(windowMaxMidi);

      // --- Grid Drawing Optimization: Draw background stripes first ---
      for (let midi = startMidi; midi <= endMidi; midi++) {
         let y = canvasHeight - ((midi - windowMinMidi) / (windowMaxMidi - windowMinMidi)) * canvasHeight;
         let nextMidi = midi + 1;
         let nextY = canvasHeight - ((nextMidi - windowMinMidi) / (windowMaxMidi - windowMinMidi)) * canvasHeight;
         // Ensure valid height for the rectangle
         if (y > nextY) {
            gridCtx.fillStyle = (midi % 2 === 0) ? '#f9f9f9' : '#ffffff';
            gridCtx.fillRect(0, nextY, canvasWidth, y - nextY);
         }
      }
      // --- Then draw lines and text ---
       for (let midi = startMidi; midi <= endMidi; midi++) {
           let y = canvasHeight - ((midi - windowMinMidi) / (windowMaxMidi - windowMinMidi)) * canvasHeight;
           // Draw horizontal grid line
           gridCtx.beginPath();
           gridCtx.moveTo(0, y);
           gridCtx.lineTo(canvasWidth, y);
           gridCtx.strokeStyle = '#ccc';
           gridCtx.lineWidth = 1;
           gridCtx.stroke();
           // Label natural notes (skip sharps)
           let noteIndex = midi % 12;
           let octave = Math.floor(midi / 12) - 1; // A0 is MIDI 21, C1 is 24. MIDI 60 is C4.
           let noteName = noteNames[noteIndex];
            // Only label natural notes (C, D, E, F, G, A, B)
           if (noteName.indexOf('#') === -1) {
               gridCtx.fillStyle = 'black';
               gridCtx.font = '12px Arial';
               // Adjust text position slightly for better readability
               gridCtx.textAlign = 'left';
               gridCtx.fillText(noteName + octave, 5, y - 3);
           }
       }
    }

    // Convert frequency to MIDI note (floating point)
    function frequencyToMidi(frequency) {
      if (frequency <= 0) return null; // Avoid Math.log2(non-positive)
      return 69 + 12 * Math.log2(frequency / 440);
    }

    // Autocorrelation algorithm for pitch detection (same as before)
    function autoCorrelate(buffer, sampleRate) {
        let SIZE = buffer.length;
        let rms = 0;
        for (let i = 0; i < SIZE; i++) {
            let val = buffer[i];
            rms += val * val;
        }
        rms = Math.sqrt(rms / SIZE);
        if (rms < 0.01) { // Not enough signal
            return -1;
        }

        let r1 = 0, r2 = SIZE - 1, thres = 0.2;
        for (let i = 0; i < SIZE / 2; i++)
            if (Math.abs(buffer[i]) < thres) { r1 = i; break; }
        for (let i = 1; i < SIZE / 2; i++)
            if (Math.abs(buffer[SIZE - i]) < thres) { r2 = SIZE - i; break; }

        buffer = buffer.slice(r1, r2);
        SIZE = buffer.length;
        if (SIZE < 2) return -1; // Added check for very short buffer after trim

        let c = new Float32Array(SIZE).fill(0); // Use Float32Array for potential performance
        for (let i = 0; i < SIZE; i++)
            for (let j = 0; j < SIZE - i; j++)
                c[i] = c[i] + buffer[j] * buffer[j + i];

        let d = 0;
        while (d < c.length - 1 && c[d] > c[d + 1]) { // Added boundary check
            d++;
        }
         if (d >= c.length -1) return -1; // Could not find initial dip

        let maxval = -1, maxpos = -1;
        // Start search from d+1 to avoid picking the DC offset peak if d=0
        for (let i = d + 1; i < SIZE; i++) {
            if (c[i] > maxval) {
                maxval = c[i];
                maxpos = i;
            }
        }

        if (maxpos <= 0 || maxpos >= c.length - 1) return -1; // Check bounds for interpolation

        let T0 = maxpos;
        // Parabolic interpolation
        let x1 = c[T0 - 1];
        let x2 = c[T0];
        let x3 = c[T0 + 1];
        let a = (x1 + x3 - 2 * x2) / 2;
        let b = (x3 - x1) / 2;
        if (a !== 0) { // Avoid division by zero
             let correctedPos = T0 - b / (2 * a);
             // Sanity check the correction, ensure it's close to original maxpos
             if (Math.abs(correctedPos - T0) < 1) {
                 T0 = correctedPos;
             }
        }

        if (T0 <= 0) return -1; // Avoid division by zero/negative frequency

        return sampleRate / T0;
    }


    // Draw graph using stored pitchHistory with current dynamic window mapping
    function drawGraph(pitchHistory, windowMinMidi, windowMaxMidi) {
      // Clear the graph canvas
      graphCtx.clearRect(0, 0, canvasWidth, canvasHeight);
      graphCtx.beginPath();
      let started = false;
      for (let i = 0; i < pitchHistory.length; i++) {
        let midi = pitchHistory[i];
        let x = canvasWidth - pitchHistory.length + i; // Draw from right to left

        // Skip if pitch not detected (null)
        if (midi === null) {
          if (started) {
            graphCtx.stroke(); // End the current line segment
            started = false;
          }
          continue;
        }

        // Map MIDI value to y-coordinate based on dynamic window
        // Clamp y-coordinate to canvas boundaries to avoid drawing outside
        let y = canvasHeight - ((midi - windowMinMidi) / (windowMaxMidi - windowMinMidi)) * canvasHeight;
        y = Math.max(0, Math.min(canvasHeight, y)); // Clamp y

        if (!started) {
          graphCtx.moveTo(x, y);
          started = true;
        } else {
          graphCtx.lineTo(x, y);
        }
      }
      if (started) {
        graphCtx.strokeStyle = 'red';
        graphCtx.lineWidth = 2;
        graphCtx.stroke(); // Draw the last segment if any
      }
    }

    // Audio processing variables
    let audioContext, analyser, mediaStreamSource;
    let bufferLength;
    let dataArray;

    // --- State Variables for Smoothing ---
    // Smoothed pitch for the actual line drawing (slightly stronger smoothing)
    let pitchSmoothed = 0;
    const PITCH_SMOOTHING_FACTOR = 0.85; // 0.8 -> 0.85 (smoother line)

    // VERY smoothed pitch used ONLY for calculating the Y-axis center (much slower update)
    let axisCenterMidiSmoothed = (fullMinMidi + fullMaxMidi) / 2; // Start in the middle
    const AXIS_SMOOTHING_FACTOR = 0.99; // 0.98 or 0.99 makes it very slow to react

    let lastDrawTime = 0;
    const FRAME_INTERVAL = 16; // Target ~60fps (1000ms / 60 ≈ 16ms)

    // Main loop: process audio, update dynamic window, grid and graph
    function update(currentTime) {
        requestAnimationFrame(update); // Request next frame immediately

        // Limit drawing frequency to avoid unnecessary work
        if (currentTime - lastDrawTime < FRAME_INTERVAL) {
            return;
        }
        lastDrawTime = currentTime;


        analyser.getFloatTimeDomainData(dataArray);
        let pitch = autoCorrelate(dataArray, audioContext.sampleRate);
        let currentMidi = null;

        if (pitch !== -1 && pitch > 0) { // Ensure pitch is valid positive frequency
             // Apply smoothing filter to the detected pitch for the line
             if (pitchSmoothed === 0) { // Initialize smoothing on first valid pitch
                 pitchSmoothed = pitch;
             } else {
                 pitchSmoothed = pitchSmoothed * PITCH_SMOOTHING_FACTOR + pitch * (1 - PITCH_SMOOTHING_FACTOR);
             }
             currentMidi = frequencyToMidi(pitchSmoothed);

             // If we have a valid MIDI note, update the SLOW axis center average
             if (currentMidi !== null) {
                 axisCenterMidiSmoothed = axisCenterMidiSmoothed * AXIS_SMOOTHING_FACTOR + currentMidi * (1 - AXIS_SMOOTHING_FACTOR);
             }
         }
         // If pitch is -1 (silence/undetected), currentMidi remains null.
         // We don't update pitchSmoothed or axisCenterMidiSmoothed during silence.

        // ** CRITICAL CHANGE: Use the very slow smoothed MIDI value for the axis center **
        let centerMidi = axisCenterMidiSmoothed;

        // Compute dynamic window boundaries based on the SLOWLY changing center
        let windowMinMidi = centerMidi - displayRange / 2;
        let windowMaxMidi = centerMidi + displayRange / 2;

        // Clamp the dynamic window within full range
        if (windowMinMidi < fullMinMidi) {
            windowMinMidi = fullMinMidi;
            windowMaxMidi = fullMinMidi + displayRange;
            // Recalculate center if clamped at bottom
            // axisCenterMidiSmoothed = windowMinMidi + displayRange / 2;
        } else if (windowMaxMidi > fullMaxMidi) { // Use 'else if' because it can't be both
            windowMaxMidi = fullMaxMidi;
            windowMinMidi = fullMaxMidi - displayRange;
            // Recalculate center if clamped at top
             // axisCenterMidiSmoothed = windowMaxMidi - displayRange / 2;
        }
        // Note: Clamping might slightly shift the *actual* displayed center if near edges.
        // Uncommenting the axisCenterMidiSmoothed updates within clamps can help recenter faster when hitting bounds.


        // --- Drawing ---
        // Redraw the grid according to the (now more stable) dynamic window
        drawDynamicGrid(windowMinMidi, windowMaxMidi);

        // Update pitch history array
        // Store the 'currentMidi' which is based on 'pitchSmoothed' (the faster average)
        pitchHistory.push(currentMidi);
        // Keep history length matching canvas width
        if (pitchHistory.length > canvasWidth) {
            pitchHistory.shift();
        }

        // Redraw the graph based on pitch history and the STABLE dynamic window
        drawGraph(pitchHistory, windowMinMidi, windowMaxMidi);

        // No need for separate requestAnimationFrame here, it's at the top of update()
    }

    // Initialize audio stream and start processing
    async function init() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        mediaStreamSource = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048; // Standard size
        // Optional: Add some smoothing to the analyser data itself
        // analyser.smoothingTimeConstant = 0.1; // Value between 0 and 1

        bufferLength = analyser.fftSize;
        dataArray = new Float32Array(bufferLength);
        mediaStreamSource.connect(analyser);

        // Initialize history with nulls to fill the screen initially
        pitchHistory = new Array(canvasWidth).fill(null);

        requestAnimationFrame(update); // Start the main loop
      } catch (e) {
        console.error('Error accessing audio stream:', e);
        alert('无法访问麦克风，请检查权限设置 (Error: ' + e.message + ')');
      }
    }

    window.addEventListener('load', init);
  </script>
</body>
</html>